// Code generated by MockGen. DO NOT EDIT.
// Source: migrations.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	entities "github.com/consensys/quorum-hashicorp-vault-plugin/src/vault/entities"
	usecases "github.com/consensys/quorum-hashicorp-vault-plugin/src/vault/use-cases"
	gomock "github.com/golang/mock/gomock"
	logical "github.com/hashicorp/vault/sdk/logical"
	reflect "reflect"
)

// MockMigrationsUseCases is a mock of MigrationsUseCases interface
type MockMigrationsUseCases struct {
	ctrl     *gomock.Controller
	recorder *MockMigrationsUseCasesMockRecorder
}

// MockMigrationsUseCasesMockRecorder is the mock recorder for MockMigrationsUseCases
type MockMigrationsUseCasesMockRecorder struct {
	mock *MockMigrationsUseCases
}

// NewMockMigrationsUseCases creates a new mock instance
func NewMockMigrationsUseCases(ctrl *gomock.Controller) *MockMigrationsUseCases {
	mock := &MockMigrationsUseCases{ctrl: ctrl}
	mock.recorder = &MockMigrationsUseCasesMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockMigrationsUseCases) EXPECT() *MockMigrationsUseCasesMockRecorder {
	return m.recorder
}

// EthereumToKeys mocks base method
func (m *MockMigrationsUseCases) EthereumToKeys() usecases.EthereumToKeysUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EthereumToKeys")
	ret0, _ := ret[0].(usecases.EthereumToKeysUseCase)
	return ret0
}

// EthereumToKeys indicates an expected call of EthereumToKeys
func (mr *MockMigrationsUseCasesMockRecorder) EthereumToKeys() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EthereumToKeys", reflect.TypeOf((*MockMigrationsUseCases)(nil).EthereumToKeys))
}

// MockEthereumToKeysUseCase is a mock of EthereumToKeysUseCase interface
type MockEthereumToKeysUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockEthereumToKeysUseCaseMockRecorder
}

// MockEthereumToKeysUseCaseMockRecorder is the mock recorder for MockEthereumToKeysUseCase
type MockEthereumToKeysUseCaseMockRecorder struct {
	mock *MockEthereumToKeysUseCase
}

// NewMockEthereumToKeysUseCase creates a new mock instance
func NewMockEthereumToKeysUseCase(ctrl *gomock.Controller) *MockEthereumToKeysUseCase {
	mock := &MockEthereumToKeysUseCase{ctrl: ctrl}
	mock.recorder = &MockEthereumToKeysUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockEthereumToKeysUseCase) EXPECT() *MockEthereumToKeysUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockEthereumToKeysUseCase) Execute(ctx context.Context, storage logical.Storage, namespace string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, storage, namespace)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute
func (mr *MockEthereumToKeysUseCaseMockRecorder) Execute(ctx, storage, namespace interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockEthereumToKeysUseCase)(nil).Execute), ctx, storage, namespace)
}

// Status mocks base method
func (m *MockEthereumToKeysUseCase) Status(ctx context.Context, namespace string) (*entities.MigrationStatus, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Status", ctx, namespace)
	ret0, _ := ret[0].(*entities.MigrationStatus)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Status indicates an expected call of Status
func (mr *MockEthereumToKeysUseCaseMockRecorder) Status(ctx, namespace interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Status", reflect.TypeOf((*MockEthereumToKeysUseCase)(nil).Status), ctx, namespace)
}
